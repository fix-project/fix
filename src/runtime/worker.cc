#include <string_view>
#include <utility>

#include "base64.hh"
#include "handle.hh"
#include "operation.hh"
#include "runtimestorage.hh"
#include "sha256.hh"
#include "task.hh"
#include "wasm-rt-content.h"

using namespace std;

#ifndef COMPILE
#define COMPILE "COMPILE MUST BE DEFINED"
#endif

void RuntimeWorker::cache( Task task, Handle result )
{
  runtimestorage_.fix_cache_.cache( task, result, queue_cb );
  schedule();
}

optional<Handle> RuntimeWorker::await( Task target, Task current )
{
  auto value = runtimestorage_.fix_cache_.get_or_add_dependency( target, current, queue_cb );
  schedule();
  return value;
}

bool RuntimeWorker::await_tree( Task task )
{
  Tree tree = runtimestorage_.get_tree( task.handle() );
  // We start from N and decrement to 0 to prevent a race condition.  If we started from zero, we could mark the
  // first of N dependencies, then get preeempted; if that dependency runs to completion in the meantime, it'll
  // reset the count back to zero and start <task> again.  This could then happen for the other N-1 dependencies,
  // leading to <task> being queued N times.
  runtimestorage_.fix_cache_.increment_blocked_count( task, tree.size() );
  size_t blocking = 0;
  for ( size_t i = 0; i < tree.size(); i++ ) {
    Task target = Task::Eval( tree.at( i ) );
    blocking = runtimestorage_.fix_cache_.add_dependency_or_decrement_blocked_count( target, task, queue_cb );
  }
  schedule();
  return blocking == 0;
}

std::optional<Handle> RuntimeWorker::do_eval( Task task )
{
  auto name = task.handle();
  if ( name.is_lazy() ) {
    return name;
  }
  optional<Handle> result;

  switch ( name.get_content_type() ) {
    case ContentType::Blob:
      return name;

    case ContentType::Tree:
      if ( !await_tree( task ) )
        return {};

      return await( Task::Fill( name ), task );

    case ContentType::Tag: {
      Tree tree = runtimestorage_.get_tree( name );

      if ( tree.at( 0 ).get_content_type() == ContentType::Blob ) {
        return name;
      }

      result = await( Task::Eval( tree.at( 0 ) ), task );
      if ( not result )
        return {};

      return await( Task::Fill( name ), task );
    }

    case ContentType::Thunk:
      Handle encode = runtimestorage_.get_thunk_encode_name( name );

      result = await( Task::Eval( encode ), task );
      if ( not result )
        return {};

      result = await( Task::Apply( result.value() ), task );
      if ( not result )
        return {};

      if ( name.is_shallow() )
        result = Handle::make_shallow( result.value() );

      return await( Task::Eval( result.value() ), task );
  }

  throw std::runtime_error( "unhandled case in eval" );
}

void RuntimeWorker::queue_job( Task task )
{
  schedq_.push( task );
}

optional<Task> RuntimeWorker::dequeue_job()
{
  // Try to pop off the local queue, steal work if that fails, return false if no work can be found
  Task task;
  bool work = runq_.pop( task );

  if ( !work ) {
    work = runtimestorage_.steal_work( task, thread_id_ );
  }

  if ( work )
    runtimestorage_.work_--;

  if ( work )
    return task;
  else
    return std::nullopt;
}

Handle RuntimeWorker::do_apply( Task task )
{
  auto name = task.handle();
  if ( not( name.is_strict() and name.is_tree() ) ) {
    if ( name.is_thunk() ) {
      throw std::runtime_error( "Attempted to apply a Thunk, not an Encode." );
    }
    throw std::runtime_error( "Attempted to apply something besides a strict tree." );
  }
  Handle function_tag = runtimestorage_.get_tree( name ).at( 1 );
  if ( function_tag.is_blob() ) {
    throw std::runtime_error( "Attempted to apply a Thunk with an invalid procedure." );
  }
  while ( !runtimestorage_.get_tree( function_tag ).at( 1 ).is_blob() ) {
    if ( not runtimestorage_.get_tree( function_tag ).at( 1 ).is_tag() ) {
      throw std::runtime_error( "Procedure is not a tag." );
    }
    function_tag = runtimestorage_.get_tree( function_tag ).at( 1 );
  }

  auto tag = runtimestorage_.get_tree( function_tag );
  const static Handle COMPILE_ELF = *RuntimeStorage::get_instance().get_ref( "compile-elf" );
  if ( tag.at( 1 ) != COMPILE_ELF ) {
    throw std::runtime_error( "Procedure is not generated by trusted compilation toolchain: generated by "
                              + RuntimeStorage::get_instance().get_display_name( tag.at( 1 ) ) );
  }
  if ( tag.at( 2 ) != Handle( "Runnable" ) ) {
    cerr << "Attempted to run non-Runnable procedure:" << endl;
    cerr << "- object: " << tag.at( 0 ) << endl;
    cerr << "- author: " << tag.at( 1 ) << endl;
    cerr << "- type: " << tag.at( 2 ).literal_blob() << endl;
    Handle handle = tag.at( 0 );
    string_view data = runtimestorage_.get_blob( handle );
    bool is_printable
      = std::count_if( data.begin(), data.end(), []( unsigned char c ) { return std::isprint( c ); } );
    if ( is_printable == data.size() ) {
      cerr << "--- ERROR ---" << endl;
      cerr << data << endl;
      cerr << "-------------" << endl;
    } else {
      cerr << "Object is not printable." << endl;
    }
    throw std::runtime_error( "Procedure is not runnable" );
  }

  Handle function_name = tag.at( 0 );
  Handle canonical_name = runtimestorage_.local_to_storage( function_name );
  if ( not runtimestorage_.name_to_program_.contains( canonical_name ) ) {
    /* Link program */
    Program program = link_program( runtimestorage_.get_blob( function_name ) );
    runtimestorage_.name_to_program_.put( canonical_name, std::move( program ) );
  }

  auto& program = runtimestorage_.name_to_program_.getMutable( canonical_name );
  runtimestorage_.set_current_procedure( canonical_name );
  __m256i output = program.execute( name );

  return output;
}

Handle RuntimeWorker::do_fill( Handle name )
{
  switch ( name.get_content_type() ) {
    case ContentType::Tree: {
      auto orig_tree = runtimestorage_.get_tree( name );
      Handle new_name = runtimestorage_.add_tree( Tree( orig_tree.size() ) );
      span_view<Handle> tree = runtimestorage_.get_tree( new_name );

      for ( size_t i = 0; i < tree.size(); ++i ) {
        auto entry = orig_tree[i];
        tree.mutable_data()[i] = entry;

        if ( entry.is_strict() and !entry.is_blob() ) {
          // the entry must have been started (the first .value) and finished (the second .value)
          tree.mutable_data()[i] = runtimestorage_.fix_cache_.get( Task::Eval( entry ) ).value();
        }
      }

      return new_name;
    }

    case ContentType::Tag: {
      auto orig_tag = runtimestorage_.get_tree( name );
      Handle new_name = runtimestorage_.add_tag( Tree( orig_tag.size() ) );
      span_view<Handle> tag = runtimestorage_.get_tree( new_name );

      auto first_entry = orig_tag[0];
      tag.mutable_data()[0] = runtimestorage_.fix_cache_.get( Task::Eval( first_entry ) ).value();
      tag.mutable_data()[1] = orig_tag[1];
      tag.mutable_data()[2] = orig_tag[2];

      return new_name;
    }

    default:
      throw std::runtime_error( "Invalid content type for fill." );
  }
}

optional<Handle> RuntimeWorker::progress( Task task )
{
  switch ( task.operation() ) {
    case Operation::Apply:
      return do_apply( task );
    case Operation::Eval:
      return do_eval( task );
    case Operation::Fill:
      return do_fill( task.handle() );
  }
  throw std::runtime_error( "invalid operation for progress" );
}

void RuntimeWorker::work()
{
  current_thread_id_ = thread_id_;
  // Wait till all threads have been primed before computation can begin
  runtimestorage_.threads_started_.wait( false );

  while ( runtimestorage_.threads_active_ ) {
    auto task = dequeue_job();
    if ( task ) {
      auto result = progress( *task );
      if ( result.has_value() )
        cache( *task, result.value() );
    } else {
      runtimestorage_.work_.wait( 0 );
    }
  }
}

void RuntimeWorker::schedule()
{
  while ( not schedq_.empty() ) {
    Task task;
    if ( not schedq_.pop( task ) ) {
      break;
    }
    runtimestorage_.schedule( task );
  }
}
