#pragma once
#include "elfloader.hh"
#include "fixpointapi.hh"
#include "handle.hh"
#include "handle_post.hh"
#include "mutex.hh"
#include "object.hh"
#include "program.hh"
#include "runtimestorage.hh"
#include "types.hh"

#include <absl/container/flat_hash_map.h>
#include <glog/logging.h>

class Runner
{
public:
  virtual void init() {};
  virtual Handle<Object> apply( Handle<ObjectTree> handle, TreeData combination ) = 0;
  virtual ~Runner() {}
};

/**
 * The standard Fixpoint Runner, which links and loads ELF files generated by wasm2c.
 */
class WasmRunner : public Runner
{
public:
  virtual void init() override {}
  virtual ~WasmRunner() {}

  WasmRunner() { wasm_rt_init(); }

  virtual Handle<Object> apply( Handle<ObjectTree> handle, TreeData combination ) override
  {
    // Check minrepo are all loaded
    if ( not fixpoint::storage->complete( handle ) ) {
      throw std::runtime_error( "Incomplete minrepo." );
    }

    std::optional<Handle<AnyTree>> function_tag {};

    while ( true ) {
      function_tag = combination->at( 1 )
                       .try_into<Expression>()
                       .and_then( &Handle<Expression>::try_into<Object> )
                       .and_then( &Handle<Object>::try_into<ObjectTree> );

      if ( not function_tag.has_value() ) {
        function_tag = combination->at( 1 )
                         .try_into<Expression>()
                         .and_then( &Handle<Expression>::try_into<Object> )
                         .and_then( &Handle<Object>::try_into<Value> )
                         .and_then( &Handle<Value>::try_into<ValueTree> );
      }

      if ( not function_tag.has_value() ) {
        throw std::runtime_error( "Function is not an object/value tree." );
      }

      combination = fixpoint::storage->get( function_tag.value() );
      auto next_level = combination->at( 1 );

      if ( next_level.try_into<Expression>()
             .and_then( &Handle<Expression>::try_into<Object> )
             .and_then( &Handle<Object>::try_into<Value> )
             .and_then( &Handle<Value>::try_into<Blob> )
             .has_value() ) {
        break;
      }
    }

    if ( not function_tag->visit<bool>( []( auto h ) { return h.is_tag(); } ) ) {
      throw std::runtime_error( "Procedure is not a tag." );
    }

    auto tag = fixpoint::storage->get( function_tag.value() );
    // const static Handle<Fix> COMPILE_ELF = fixpoint::storage->labeled( "compile-elf" );

    // if ( tag->at( 0 ) != COMPILE_ELF ) {
    //   throw std::runtime_error( "Procedure is not generated by trusted compilation toolchain" );
    // }

    if ( tag->at( 2 ) != Handle<Literal>( "Runnable" ).into<Fix>() ) {
      std::cerr << "Attempted to run non-Runnable procedure:" << std::endl;
      std::cerr << "- object: " << tag->at( 1 ) << std::endl;
      std::cerr << "- author: " << tag->at( 2 ) << std::endl;
      // std::cerr << "- type: " << std::string_view( storage_.get( tag->at( 2 ) ) ) << endl;
      Handle<Fix> handle = tag->at( 1 );
      auto data = fixpoint::storage->get( handle::extract<Blob>( handle )->try_into<Named>().value() );
      bool is_printable = std::count_if(
        data->span().begin(), data->span().end(), []( unsigned char c ) { return std::isprint( c ); } );
      if ( is_printable == data->size() ) {
        std::cerr << "--- ERROR ---" << std::endl;
        std::cerr << std::string_view( data->data(), data->size() ) << std::endl;
        std::cerr << "-------------" << std::endl;
      } else {
        std::cerr << "Object is not printable." << std::endl;
      }
      throw std::runtime_error( "Procedure is not runnable" );
    }

    auto function_name = tag->at( 1 )
                           .try_into<Expression>()
                           .and_then( &Handle<Expression>::try_into<Object> )
                           .and_then( &Handle<Object>::try_into<Value> )
                           .and_then( &Handle<Value>::try_into<Blob> )
                           .and_then( &Handle<Blob>::try_into<Named> )
                           .value();

    if ( !programs_.read()->contains( function_name ) ) {
      auto program = link_program( fixpoint::storage->get( function_name )->span() );
      programs_.write()->emplace( function_name, std::move( program ) );
    }

    const Program& program = programs_.read()->at( function_name );

    fixpoint::current_procedure = function_name;
    return program.execute( handle );
  }

private:
  SharedMutex<absl::flat_hash_map<Handle<Named>, Program>> programs_ {};
};

/**
 * For testing and development purposes: a Runner which interprets the first element of a combination as a function
 * pointer and directly jumps to it.
 */
class PointerRunner : public Runner
{

public:
  virtual void init() override {}
  virtual ~PointerRunner() {}

  virtual Handle<Object> apply( Handle<ObjectTree> handle, TreeData combination ) override
  {
    auto procedure = combination->at( 0 )
                       .try_into<Expression>()
                       .and_then( &Handle<Expression>::try_into<Object> )
                       .and_then( &Handle<Object>::try_into<Value> )
                       .and_then( &Handle<Value>::try_into<Blob> )
                       .and_then( &Handle<Blob>::try_into<Literal> )
                       .value();
    uint64_t addr( procedure );
    auto x = reinterpret_cast<Handle<Object> ( * )( Handle<ObjectTree> )>( addr );
    return x( handle );
  }
};
