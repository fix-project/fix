""" Generates a wat file that defines the ro/rw memory operations to and from fixpoint program memory. """
import os

MEM_SIZES = {
    "rw": 8,
    "ro": 8,
}

OTHER_MEM_TYPES = ["program", "flatware"]

MODULE = 'asm-flatware'
FIXPOINT_MODULE = 'fixpoint'
HEADER = ' This file was automatically generated by generate.py'
WAT_DESCRIPTION = ' Defines and exports wasm tables and memories and helper ' \
                    'functions for those tables and memories.'
C_DESCRIPTION = ' Imports wasm tables, memories, and helper functions from '\
                    f'"{MODULE}" and imports fixpoint api functions.'


# wat commands
# imports
WAT_IMPORT_FMEM = '(import "c-flatware" "memory" (memory $flatware_mem 0))\n'
WAT_IMPORT_MEM = '(import "fixpoint_storage" "{type}_mem_{index}" (memory ${type}_mem_{index} 0))\n'
WAT_IMPORT_PMEM = '(import "wasi_command" "memory" (memory $program_mem 0))\n'
WAT_IMPORT_START = '(import "wasi_command" "_start" (func $start))\n'

# gets
WAT_GET_I32 = '(func (export "get_i32_{type}") (param $offset i32) (result i32)\n\
    (local.get $offset)\n\
    (i32.load ${type}_mem)\n\
    )\n'

WAT_SET_I32 = '(func (export "set_i32_{type}") (param $offset i32) (param $value i32)\n\
    (i32.store ${type}_mem (local.get $offset) (local.get $value))\n\
    )\n'

# copies
WAT_COPY_PTR = '(func (export "{src}_mem_to_{dest}_mem") (param ${dest}_offset i32) (param ${src}_offset i32) (param $len i32)\n\
    (memory.copy ${src}_mem ${dest}_mem\n\
    (local.get ${dest}_offset)\n\
    (local.get ${src}_offset)\n\
    (local.get $len))\n\
    )\n'

WAT_COPY_MEM_TO_DEST = '(func (export "{type}_mem_{index}_to_{dest}_mem") (param ${dest}_offset i32) (param ${type}_offset i32) (param $len i32)\n\
    (memory.copy ${type}_mem_{index} ${dest}_mem\n\
    (local.get ${dest}_offset)\n\
    (local.get ${type}_offset)\n\
    (local.get $len))\n\
    )\n'

WAT_COPY_SRC_TO_RW_MEM = '(func (export "{src}_mem_to_rw_mem_{index}") (param $rw_offset i32) (param ${src}_offset i32) (param $len i32)\n\
    (memory.copy ${src}_mem $rw_mem_{index}\n\
    (local.get $rw_offset)\n\
    (local.get ${src}_offset)\n\
    (local.get $len))\n\
    )\n'

# functions
WAT_EXIT = '(tag $exit)\n\
    (func (export "exit") (throw $exit))\n'

WAT_RUN_START = '(func (export "run-start") (try (do (call $start)) (catch $exit)))\n'

# generation
def write_wat(path):
    with open(f'{path}/{MODULE}.wat', 'w+') as f:
        f.write(f'(module\n')
        f.write(f';;{HEADER}\n')
        f.write(f';;{WAT_DESCRIPTION}\n')
        # declare memory
        f.write(WAT_IMPORT_FMEM)
        for mem_type, size in MEM_SIZES.items():
            for i in range(size):
                f.write(WAT_IMPORT_MEM.format(type=mem_type, index=i))
        f.write(WAT_IMPORT_PMEM)
        f.write(WAT_IMPORT_START)

        # i32 gets and sets
        for mem_type in OTHER_MEM_TYPES:
            f.write(WAT_GET_I32.format(type=mem_type))
            f.write(WAT_SET_I32.format(type=mem_type))
        
        # memory copies
        f.write(WAT_COPY_PTR.format(src='flatware', dest='program'))
        f.write(WAT_COPY_PTR.format(src='program', dest='flatware'))

        for other_mem_type in OTHER_MEM_TYPES:
            for mem_type, size in MEM_SIZES.items():
                for i in range(size):
                    f.write(WAT_COPY_MEM_TO_DEST.format(type=mem_type, index=i, dest=other_mem_type))

        for other_mem_type in OTHER_MEM_TYPES:
            for i in range(MEM_SIZES['rw']):
                f.write(WAT_COPY_SRC_TO_RW_MEM.format(src=other_mem_type, index=i))

        # functions
        f.write(WAT_EXIT)
        f.write(WAT_RUN_START)
        f.write(')\n')

# c commands
# gets / sets
C_GET_I32 = 'extern int32_t get_i32_{type}( int32_t offset )\n\
    __attribute__( (import_module( "{module}" ), import_name( "get_i32_{type}" ) ) );\n'
C_SET_I32 = 'extern void set_i32_{type}( int32_t offset, int32_t value )\n\
    __attribute__( (import_module( "{module}" ), import_name( "set_i32_{type}" ) ) );\n'

# copies
C_COPY_PTR = 'extern void {src}_mem_to_{dest}_mem( int32_t {dest}_offset, int32_t {src}_offset, int32_t len )\n\
    __attribute__( (import_module( "{module}" ), import_name( "{src}_mem_to_{dest}_mem" ) ) );\n'

C_COPY_MEM_TO_DEST = 'extern void {type}_mem_{index}_to_{dest}_mem( int32_t {dest}_offset, int32_t {type}_offset, int32_t len )\n\
    __attribute__( (import_module( "{module}" ), import_name( "{type}_mem_{index}_to_{dest}_mem" ) ) );\n'

C_COPY_SRC_TO_RW_MEM = 'extern void {src}_mem_to_rw_mem_{index}( int32_t rw_offset, int32_t {src}_offset, int32_t len )\n\
    __attribute__( (import_module( "{module}" ), import_name( "{src}_mem_to_rw_mem_{index}" ) ) );\n'
    
# function list
C_COPY_MEM_TO_DEST_NAME = '{type}_mem_{index}_to_{dest}_mem'
C_COPY_SRC_TO_RW_MEM_NAME = '{src}_mem_to_rw_mem_{index}'

C_COPY_FUNC_LIST = 'static void (*const {src}_to_{dest}_functions[]) ( int32_t, int32_t, int32_t ) = {{{functions}}};\n'

C_COPY_MEM_TO_DEST_PROTO = 'void {src}_mem_to_{dest}_mem( int32_t {src}_mem_id, int32_t {dest}_offset, int32_t {src}_offset, int32_t len );\n'
C_COPY_MEM_TO_DEST_FUNC = 'void {src}_mem_to_{dest}_mem( int32_t {src}_mem_id, int32_t {dest}_offset, int32_t {src}_offset, int32_t len )\n\
    {{\n\
    {src}_to_{dest}_functions[{src}_mem_id]( {dest}_offset, {src}_offset, len );\n\
    }}\n'

C_COPY_SOURCE_TO_RW_MEM_PROTO = 'void {src}_mem_to_rw_mem( int32_t rw_mem_id, int32_t rw_offset, int32_t {src}_offset, int32_t len);\n'
C_COPY_SOURCE_TO_RW_MEM_FUNC = 'void {src}_mem_to_rw_mem( int32_t rw_mem_id, int32_t rw_offset, int32_t {src}_offset, int32_t len )\n\
    {{\n\
    {src}_to_rw_functions[rw_mem_id]( rw_offset, {src}_offset, len );\n\
    }}\n'


# code generation
def write_c(path):
    with open(f'{path}/{MODULE}.c', 'w+') as f:
        f.write(f'//{HEADER}\n')
        f.write(f'//{C_DESCRIPTION}\n')

        # includes
        f.write(f'#include "{MODULE}.h"\n')

        # clang
        f.write(f'#pragma clang diagnostic push\n')
        f.write(f'#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"\n')

        for dest in OTHER_MEM_TYPES:
            for mem_type, size in MEM_SIZES.items():
                for i in range(size):
                    f.write(C_COPY_MEM_TO_DEST.format(type=mem_type, index=i, dest=dest, module=MODULE))
                f.write(C_COPY_FUNC_LIST.format(src=mem_type, dest=dest, functions=', '.join([C_COPY_MEM_TO_DEST_NAME.format(type=mem_type, index=i, dest=dest) for i in range(size)])))
                f.write(C_COPY_MEM_TO_DEST_FUNC.format(src=mem_type, dest=dest))

        for src in OTHER_MEM_TYPES:
            for i in range(MEM_SIZES['rw']):
                f.write(C_COPY_SRC_TO_RW_MEM.format(src=src, index=i, module=MODULE))
            f.write(C_COPY_FUNC_LIST.format(src=src, dest='rw', functions=', '.join([C_COPY_SRC_TO_RW_MEM_NAME.format(src=src, index=i) for i in range(MEM_SIZES['rw'])])))
            f.write(C_COPY_SOURCE_TO_RW_MEM_FUNC.format(src=src))
        
        # clang pt. 2
        f.write(f'#pragma clang diagnostic pop\n')


# header generation
def write_header(path):
    with open(f'{path}/{MODULE}.h', 'w+') as f:
        f.write(f'//{HEADER}\n')
        f.write(f'//{C_DESCRIPTION}\n')

        # includes
        f.write('#include <stdint.h>\n')

        # gets / sets
        for mem_type in OTHER_MEM_TYPES:
            f.write(C_GET_I32.format(type=mem_type, module=MODULE))
            f.write(C_SET_I32.format(type=mem_type, module=MODULE))

        # copies
        f.write(C_COPY_PTR.format(src='flatware', dest='program', module=MODULE))
        f.write(C_COPY_PTR.format(src='program', dest='flatware', module=MODULE))

        # function prototypes
        for dest in OTHER_MEM_TYPES:
            for mem_type in MEM_SIZES.keys():
                f.write(C_COPY_MEM_TO_DEST_PROTO.format(src=mem_type, dest=dest))

        for src in OTHER_MEM_TYPES:
            f.write(C_COPY_SOURCE_TO_RW_MEM_PROTO.format(src=src))

        # functions
        f.write(f'extern void run_start( void ) __attribute__( ( import_module( "{MODULE}" ), import_name( "run-start" ) ) );\n')
        f.write(f'__attribute__( ( noreturn ) ) void flatware_exit( void )\n__attribute__( ( import_module( "{MODULE}" ), import_name( "exit" ) ) );\n')


if __name__ == "__main__":
    path = os.getcwd()
    print(f'Generating {MODULE} in {path}')
    write_wat(path)
    write_c(path)
    write_header(path)
    print(f'Generated {MODULE} in {path}')
